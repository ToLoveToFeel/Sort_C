#include "ExchangeSort.h"

/*****************************************************
*  函数名称：qppx
*  功能说明：冒泡排序(升序)
*  参数说明：SqList* L, L为结构体指针
*  函数返回：void
*  修改时间：2018-8-26   已测试
*  数据存储：数组,链表
*  附加说明：稳定的，平均O(n2)，最好O(n),最坏O(n2),额外空间O(1)
*****************************************************/
void qppx(SqList* L)
{
	int i, j, k;
	k = 1;	 //如果有序，只做一趟
	for(i = 1; i <= L->length && k > 0; i++)
	{
		k = 0;
		for(j = 1; j <= L->length - i; j++)
			if(L->r[j] > L->r[j+1])
			{
				L->r[0] = L->r[j];
				L->r[j] = L->r[j+1];
				L->r[j+1] = L->r[0];
				k++;
			}
	}
}

/*****************************************************
*  函数名称：Qsort
*  功能说明：快速排序(升序)
*  参数说明：SqList* L, L为结构体指针
			 l和h为所选快排范围
*  函数返回：void
*  修改时间：2018-8-26   已测试
*  数据存储：只能数组
*  附加说明：不稳定的(7,4,4)，O(nlog2n)，最坏O(n2)，额外空间O(log2n)
*****************************************************/
void QSort(SqList* L, int l, int h)
{ 
	int t;
	if (l < h)
	{
		t = partition(L, l, h);
		QSort (L, l, t-1);
		QSort (L, t+1, h);
	}
}

int partition(SqList* L, int l, int h)
{ 
	L->r[0] = L->r[l];            //取基准为待排序范围的第一个数据，放入r[0]
	while(l < h)
	{
		while((l < h) && (L->r[h] >= L->r[0])) 
			h--;
		if(l < h)
		{
			L->r[l] = L->r[h];
			l++;
		}
		while((l < h) && (L->r[l] <= L->r[0])) 
			l++;
		if(l < h)
		{
			L->r[h] = L->r[l];
			h--;
		}
	}
	L->r[l] = L->r[0];              //将基准从r[0]处移到左右边界重合处，即：基准排序后的最终位置（ l=h ）
	return l;
}