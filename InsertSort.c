#include "InsertSort.h"

/*****************************************************
*  函数名称：insertSort
*  功能说明：直接插入排序(升序)
*  参数说明：SqList* L, L为结构体指针
*  函数返回：void
*  修改时间：2018-8-26   已测试
*  数据存储：数组,链表
*  附加说明：稳定的,平均O(n2)，最好O(n),最坏O(n2),额外空间O(1)
*****************************************************/
void insertSort(SqList* L)
{
	int i, j;
	for(i = 2; i <= L->length; i++)          //从第2个数据开始插入,n=L.length
		if(L->r[i]<L->r[i-1])             //第i个数据比前面已经有序的i-1个数据最大的小
		{
			L->r[0] = L->r[i];              //将第i个数据放入哨兵位置
			L->r[i] = L->r[i-1];
			for(j = i - 2; L->r[0] < L->r[j]; --j)    //L.r[0]存放的是此次要插入的第i个数据
				L->r[j+1] = L->r[j];

			L->r[j+1] = L->r[0];
		}
}


/*****************************************************
*  函数名称：BinsertSort
*  功能说明：二分插入排序(升序)
*  参数说明：SqList* L, L为结构体指针
*  函数返回：void
*  修改时间：2018-8-26   已测试
*  数据存储：只能数组
*  附加说明：稳定的,平均O(n2)，最好O(n),最坏O(n2),额外空间O(1)
*****************************************************/
void BinsertSort(SqList* L)
{
	int i, j;
	int high, low, mid;
	for(i = 2; i <= L->length; i++)
		if(L->r[i] < L->r[i-1])
		{
			L->r[0] = L->r[i];
			low = 1;
			high = i-1;
			while(low <= high)
			{
				mid = (low + high) / 2;
				if(L->r[0] < L->r[mid])
					high = mid - 1;
				else
					low = mid + 1;
			}
				for(j = i - 1; j >= high + 1; j--)
					L->r[j+1] = L->r[j];
				L->r[high+1] = L->r[0];
		}
}


/*****************************************************
*  函数名称：shell
*  功能说明：希尔排序(升序)
*  参数说明：SqList* L, L为结构体指针
		     int d, d为增量
*  函数返回：void
*  修改时间：2018-8-26   已测试
*  数据存储：建议数组，链表实现比较困难
*  附加说明：不稳定的(7,4,4)，O(n1.5)，额外空间O(1)
*****************************************************/
void shell(SqList* L, int d)
{
	int i, j;
	for(i = d + 1; i <= L->length; i++)
		if(L->r[i] < L->r[i-d])
		{
			L->r[0] = L->r[i];
			for(j = i - d; (j > 0) && (L->r[0] < L->r[j]); j = j - d)
				L->r[j+d] = L->r[j];
			L->r[j+d] = L->r[0];
		}
}